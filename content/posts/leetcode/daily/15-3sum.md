---
title: "22. Generate Parentheses"
date: 2021-06-04
lastmod: 2021-06-04
tags: [Golang, 数据结构与算法]
categories: [LeetCode]
draft: false
---

[LeetCode 刷题笔记系列](/posts/leetcode/leetcode)，力扣（LeetCode）[第 15 题](https://leetcode-cn.com/problems/3sum)的题解。

<!--more-->

## 题目

Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**

```text
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

**Example 2:**

```text
Input: nums = []
Output: []
```

**Example 3:**

```text
Input: nums = [0]
Output: []
```

**Constraints:**

- `0 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`

## 题解

一开始想用哈希表来存储所有数字，这样二重循环就行了，但没想到怎么去重。

看了答案，排序就行了。排序后可以通过和上一个数比较来判断保证不重复。但三重循环时间复杂度太高，排序还有另一个好处，就是寻找第三个数的时候从后往前，和第二数重叠时就可以结束查找了，这样能大大降低时间复杂度。

最后用 Golang 的实现如下（抄的题解）：

```go
func threeSum(nums []int) [][]int {
    res := [][]int{}
    sort.Ints(nums)
    for i := 0; i < len(nums); i++ {
        if i > 0 && nums[i] == nums[i-1] {
            continue
        }
        k := len(nums) - 1
        for j := i + 1; j < len(nums); j++ {
            if j > i+1 && nums[j] == nums[j-1] {
                continue
            }
            for k > j && nums[k] > -(nums[i]+nums[j]) {
                k--
            }
            if k == j {
                break
            }
            if nums[k] == -(nums[i] + nums[j]) {
                res = append(res, []int{nums[i], nums[j], nums[k]})
            }
        }
    }
    return res
}
```
