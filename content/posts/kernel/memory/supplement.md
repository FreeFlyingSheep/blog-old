---
title: "Linux 内存管理 (补充内容)"
date: 2020-07-27
lastmod: 2020-07-30
tags: [Linux 内核, 内存管理]
categories: [Kernel]
draft: false
---

根据《深入理解 Linux 内核》(第三版) 和《Linux 内核设计与实现》(原书第 3 版) 内存管理部分的整理和补充，补充介绍前面笔记未涉及的内容。代码部分基于 Linux kernel release 2.6.11.12。

<!--more-->

## 内存池

内存池允许一个内核成分，如块设备子系统，仅在内存不足的紧急情况下分配一些动态内存来使用。

注意内存池与保留的页框池 (见[管理区分配器](/posts/kernel/memory/zone_allocator)) 的区别。保留的页框池是用于满足中断处理程序或内部临界区发出的原子分配请求的；而内存池是动态内存的储备，只能被特定的内核成分（池的拥有者）使用。

拥有者通常不使用内存池的储备（而是从普通内存中分配），如果动态内存变得极其稀有以至于所有普通内存分配请求都失败的话，那么内核成分就能调用特地的内存池函数提取储备得到所需的内存。当然，这已经是最后的解决手段了。

## 高端内存页框的内存映射

内核可以采用三种不同的机制讲页框映射到高端内存：永久内核映射、临时内核映射和非连续内存分配。

永久内核映射允许内核建立高端页框到内核地址空间的长期映射。当空闲页表项不存在（高端内存上没有页表项可以用作页框的窗口）时，可能会阻塞当前进程。因此，它不能用于中断处理程序和可延迟函数。

临时内核映射比永久内核映射的实现要简单。它不会阻塞当前进程，可以用于中断处理程序和可延迟函数。但它必须保证当前没有其他的内核控制路径在使用相同的映射，为了确保同一窗口不会被两个不同的路径同时使用，每个内核成分只能使用专门提供给它的窗口。留给临时映射的窗口很少，因此只能同时建立很少的临时内核映射。

## slub 分配器

slub 分配器逐渐取代了 slab 分配器，成为默认的内存分配器。

slub 分配器在 2.6.22 版本引入，它具有设计简单、代码精简、额外内存占用率小、扩展性高，性能优秀、方便调试等很多优点。

## 非连续内存区管理

非连续内存分配用到的函数是 vmalloc()，它的用法和 kmalloc() 相同。

vmalloc() 为了把物理上不连续的页转换为虚拟地址空间上连续的页，必须专门建立页表项，而且因为它们物理上是不连续的，所以必须一个一个进行映射，这会导致比直接内存映射大得多的 TLB 抖动。

尽管在某些情况下才需要物理上的连续内存块，但出于性能的考虑，很多内核代码都使用 kmalloc()。除非在不得已时才使用 vmalloc()，比如动态装载模块时，需要获得大块内存。

## 分配函数的选择

如果需要连续的物理页，可以使用某个低级页分配器 ([基础部分](/posts/kernel/memory/basis.md)里请求页框和释放页框的函数/宏) 或 `kmalloc()` 函数。

对于中断处理程序和其他不能睡眠的代码段，使用 `GFP_ATOMIC` 表示不进行睡眠的高优先级分配。

对于可以睡眠的代码，使用 `GFP_KERNEL` 表示如果有必要可以进行睡眠。

如果想从高端内存进行分配，可以使用 `alloc_pages()` 函数。
该函数返回一个指向 `struct page` 结构的指针，而不是一个指向某个逻辑地址的指针。因为高端内存很可能没有被映射，要获得真正的指针，需要调用 `kmap()` 函数把高端内存映射到内核的逻辑地址空间。

如果不需要物理上连续的页，而仅仅需要虚拟地址上连续的页，可以使用 `vmalloc()` 函数 (但该函数相对 `kmalloc()` 有一定的性能损失)。

如果要创建和撤销很多大的数据结构，可以考虑建立 slab 高速缓存。

## 内存管理相关函数调用关系

分配连续内存的函数调用关系大致如下：

![分配连续内存的函数调用关系](/images/kernel/memory/alloc_memory.png)

释放连续内存的函数调用关系大致如下：

![释放连续内存的函数调用关系](/images/kernel/memory/free_memory.png)
